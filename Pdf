import os, re, sys
import fitz  # PyMuPDF
import numpy as np
import pandas as pd

# OCR (이미지 PDF 대비)
import cv2
import pytesseract
from pytesseract import Output


# --- (선택) 환경변수로 Tesseract 경로 지정 가능 ---
if os.environ.get("TESSERACT_CMD"):
    pytesseract.pytesseract.tesseract_cmd = os.environ["TESSERACT_CMD"]
# --- 파일 선택 다이얼로그 ---
def pick_pdf_file():
    try:
        import tkinter as tk
        from tkinter import filedialog, messagebox
        root = tk.Tk()
        root.withdraw()
        path = filedialog.askopenfilename(
            title="처리할 PDF를 선택하세요",
            filetypes=[("PDF files", "*.pdf;*.PDF")]
        )
        root.update()
        root.destroy()
        return path
    except Exception:
        return None
# --- 간단 PDF 유효성 검사 ---
def is_valid_pdf(path: str) -> bool:
    try:
        if not os.path.isfile(path) or os.path.getsize(path) < 10:
            return False
        with open(path, "rb") as f:
            head = f.read(1024)
        return b"%PDF-" in head
    except Exception:
        return False
# ========================= OCR & PDF 텍스트 =========================
def extract_words_pdf(page):
    words = page.get_text("words")
    rows = []
    for (x0, y0, x1, y1, text, *_rest) in words:
        rows.append({
            "text": text,
            "x0": x0, "y0": y0, "x1": x1, "y1": y1,
            "cx": (x0 + x1) / 2, "cy": (y0 + y1) / 2
        })
    return pd.DataFrame(rows)

def preprocess_for_ocr(img_bgr):
    gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (3, 3), 0)
    gray = cv2.normalize(gray, None, 0, 255, cv2.NORM_MINMAX)
    thr = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]
    return thr
    
def ocr_words(page, zoom=5.0, whitelist="()R0123456789"):
    mat = fitz.Matrix(zoom, zoom)
    pix = page.get_pixmap(matrix=mat, alpha=False)
    img = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.h, pix.w, 3).copy()

    binimg = preprocess_for_ocr(img)

    # Tesseract OSD를 사용하여 텍스트 회전 각도 감지 및 보정
    rotation_angle = 0
    try:
        osd_data = pytesseract.image_to_osd(binimg, output_type=Output.DICT)
        rotation_angle = int(osd_data.get('rotate', 0))
    except Exception:
        pass
    
    rotated_binimg = binimg
    
    # 감지된 각도에 따라 이미지 회전 보정
    if rotation_angle == 90:
        rotated_binimg = cv2.rotate(binimg, cv2.ROTATE_90_COUNTERCLOCKWISE)
    elif rotation_angle == 180:
        rotated_binimg = cv2.rotate(binimg, cv2.ROTATE_180)
    elif rotation_angle == 270:
        rotated_binimg = cv2.rotate(binimg, cv2.ROTATE_90_CLOCKWISE)

    config = f"--oem 3 --psm 6 -c tessedit_char_whitelist={whitelist}"
    # 보정된 이미지로 OCR 실행
    df = pytesseract.image_to_data(rotated_binimg, output_type=Output.DATAFRAME, config=config)
    
    df = df.dropna()
    if "conf" in df.columns:
        df = df[df["conf"].astype(float) >= 35].copy()
    if df.empty:
        return pd.DataFrame(columns=["text","x0","y0","x1","y1","cx","cy"])

    df["x0"] = df["left"]; df["y0"] = df["top"]
    df["x1"] = df["left"] + df["width"]; df["y1"] = df["top"] + df["height"]
    df["cx"] = df["x0"] + df["width"]/2
    df["cy"] = df["y0"] + df["height"]/2

    # OCR px → PDF pt 좌표 스케일링
    rotated_pix_h, rotated_pix_w = rotated_binimg.shape[:2]
    x_scale = page.rect.width  / rotated_pix_w
    y_scale = page.rect.height / rotated_pix_h
    
    for col in ["x0","x1","cx"]:
        df[col] = df[col] * x_scale
    for col in ["y0","y1","cy"]:
        df[col] = df[col] * y_scale

    return df[["text","x0","y0","x1","y1","cx","cy"]].copy()

# ========================= 토큰 추출 & 그룹화 =========================
def find_R_with_number(df, r_token_regex=r"\(?R[0-9]{1,3}\)?"):
    pattern = re.compile(r_token_regex)
    rows = []
    for _, t in df.iterrows():
        txt = str(t["text"]).strip()
        if pattern.fullmatch(txt):
            num_only = re.sub(r"\D", "", txt)
            rows.append({
                "token": txt,
                "num": num_only,
                "x": t["cx"], "y": t["cy"],
                "x0": t["x0"], "y0": t["y0"], "x1": t["x1"], "y1": t["y1"]
            })
    return pd.DataFrame(rows)

def group_tokens_by_x_and_y(tokens, x_tol=20.0, y_tol=15.0, use_adaptive_tol=True, y_k=1.2):
    if tokens.empty:
        return tokens.copy()

    df = tokens.copy().reset_index(drop=True)

    # x_tol 보정(문자 박스 폭 기반)
    if use_adaptive_tol and {"x0", "x1"}.issubset(df.columns):
        median_w = float(np.median((df["x1"] - df["x0"]).abs()))
        if median_w > 0:
            x_tol = max(x_tol, 1.5 * median_w)
    # 열 클러스터링(오른쪽→왼쪽 생성)
    cols = []
    order = df.sort_values("x", ascending=False).index.tolist()
    for idx in order:
        x = df.at[idx, "x"]
        best_j, best_dx = None, None
        for j, col in enumerate(cols):
            dx = abs(x - col["x"])
            if dx <= x_tol and (best_dx is None or dx < best_dx):
                best_dx, best_j = dx, j
        if best_j is None:
            cols.append({"x": float(x), "idxs": [idx]})
        else:
            col = cols[best_j]
            col["idxs"].append(idx)
            col["x"] = float(np.mean(df.loc[col["idxs"], "x"]))
    # ColumnID: 오른쪽이 1
    cols = sorted(cols, key=lambda c: c["x"], reverse=True)
    col_id_map = {}
    for c_id, col in enumerate(cols, start=1):
        for i in col["idxs"]:
            col_id_map[i] = c_id
    df["ColumnID"] = df.index.map(col_id_map)

    # 각 열 내부 y 오름차순으로 그룹 분리(적응형 임계)
    group_id = 0
    group_ids = [None] * len(df)
    for c in cols:
        col_indices = sorted(c["idxs"], key=lambda i: df.at[i, "y"])  # 작은 y 먼저
        if len(col_indices) >= 2:
            ys = [df.at[i, "y"] for i in col_indices]
            diffs = np.diff(ys)              # 오름차순 → 양수
            diffs = np.abs(diffs)
            med_dy = float(np.median(diffs)) if len(diffs) else 0.0
            split_thr = max(y_tol, y_k * med_dy)
        else:
            split_thr = y_tol
        prev_y = None
        for i in col_indices:
            y = df.at[i, "y"]
            if prev_y is None:
                group_id += 1
            else:
                if abs(y - prev_y) > split_thr:
                    group_id += 1
            group_ids[i] = group_id
            prev_y = y

    df["GroupID"] = group_ids
    df = df.sort_values(by=["ColumnID", "GroupID", "y"], ascending=[True, True, True]).reset_index(drop=True)
    return df

# ========================= 메인 처리 =========================
def main():
    # 1) PDF 선택
    pdf_path = pick_pdf_file()
    if not pdf_path:
        print("선택된 PDF가 없습니다.")
        return
    if not is_valid_pdf(pdf_path):
        print("유효한 PDF가 아닙니다. 파일을 다시 선택해주세요.")
        return

    # 2) 열기
    try:
        doc = fitz.open(pdf_path)
    except Exception as e:
        print(f"PDF 열기 실패: {e}")
        return

    # 3) 페이지 처리
    all_rows = []
    for i, page in enumerate(doc):
        
        # PDF 메타데이터 회전 정규화: 페이지의 좌표계 자체를 가로 방향(0도)으로 강제 설정
        if page.rotation != 0:
            page.set_rotation(0)
            
        words_pdf = extract_words_pdf(page)
        # OCR 사용 여부 결정: 텍스트가 없거나(이미지 PDF) 문자 수가 적으면 OCR 사용
        use_ocr = words_pdf.empty or words_pdf["text"].astype(str).str.contains(r"[A-Za-z0-9]", regex=True).sum() < 3
        
        # OCR을 사용하는 경우: OSD 기반 자동 회전 보정이 적용된 ocr_words 함수 사용
        words = ocr_words(page, zoom=5.0) if use_ocr else words_pdf
        
        tokens = find_R_with_number(words)
        tokens = group_tokens_by_x_and_y(tokens, x_tol=20.0, y_tol=15.0, use_adaptive_tol=True, y_k=1.2)

        if not tokens.empty:
            tokens.insert(0, "page", i + 1)
            tokens.insert(1, "source", os.path.basename(pdf_path))
            all_rows.append(tokens)

    if not all_rows:
        print("토큰을 찾지 못했습니다.")
        return

    out = pd.concat(all_rows, ignore_index=True)
    
    # ----------------------------------------------------
    # [수정 사항] 엑셀 파일 저장 시 두 개의 시트 생성
    # ----------------------------------------------------
    
    # 4-1) 결과 시트 (그룹별 합계)
    grouped_result = (
        out.groupby(["source", "page", "GroupID"])["num"]
           .apply(lambda x: ",".join(map(str, x)))
           .reset_index()
    )
    result_final = grouped_result.rename(columns={"GroupID": "group"})[["group", "num"]]
    
    # 4-2) 좌표 시트 (상세 정보)
    coordinate_cols = ['source', 'page', 'GroupID', 'ColumnID', 'token', 'num', 'x0', 'y0', 'x1', 'y1', 'x', 'y']
    coordinates_final = out[coordinate_cols].rename(columns={"GroupID": "group", "ColumnID": "column"})

    # 5) 같은 폴더에 저장
    root, _ = os.path.splitext(pdf_path)
    out_xlsx = f"{root}_data.xlsx"
    out_dir = os.path.dirname(out_xlsx)
    if out_dir:
        os.makedirs(out_dir, exist_ok=True)
        
    # 두 시트를 하나의 Excel 파일에 저장
    with pd.ExcelWriter(out_xlsx, engine="openpyxl") as xw:
        result_final.to_excel(xw, index=False, sheet_name="Result")
        coordinates_final.to_excel(xw, index=False, sheet_name="Coordinates")

    print(f"저장 완료: {out_xlsx}")

if __name__ == "__main__":
    main()
